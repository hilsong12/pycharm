# -*- coding: utf-8 -*-
"""AI_exam02_principles_of_deeplearning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13a1J_jel2CPI66Ijr0yiclUsuJJRLqoV
"""

import numpy as np
import matplotlib.pyplot as plt

class add_graph:
  def __init__(self):
      pass
  def forward(self,x,y):
      out= x+y
      return out
  def backward(self,dout):
      dx = dout*1
      dy = dout*1
      return dx, dy

class mul_graph:
  def __init__(self):
        self.x= None
        self.y= None
  def forward(self,x,y):
        self.x= x
        self.y= y
        out = x*y
        return out
  def backward(self,dout):
        dx = dout*self.y
        dy = dout*self.x
        return dx,dy

class mse_graph:
  def __init__(self):
        self.loss= None
        self.x= None
        self.y= None
        self.t= None
  def forward(self,y,t):   #y가 타겟이 되도록 만들어야 한다.
        self.t= t
        self.y= y
        self.loss= np.mean((self.y - self.t)**2)
        return self.loss
  def bakcward(self,x,dout=1):
       data_size= self.t.shape[0]
       dweight_mse = (((self.y- self.t)*x).sum() *2)/data_size
       dbias_mse = (((self.y- self.t)).sum() *2)/data_size
       return dweight_mse, dbias_mse

g = add_graph()
print(g.forward(2, 3))

apple = 100
apple_num = 2
orange = 150
orange_num = 3
tax = 1.1

mul_apple_graph = mul_graph()
mul_orange_graph = mul_graph()
add_apple_orange_graph = add_graph()
mul_tax_graph = mul_graph()

apple_price =mul_apple_graph.forward(apple, apple_num)
orange_price = mul_orange_graph.forward(orange, orange_num)
all_price = add_apple_orange_graph.forward(apple_price, orange_price)
total_price= mul_tax_graph.forward(all_price, tax)
print(total_price)

dprice = 1
dall_price, dtax = mul_tax_graph.backward(dprice)
dapple_price, dorange_price = add_apple_orange_graph.backward(dall_price)
dorange, dorange_num= mul_orange_graph.backward(dorange_price)
dapple,dapple_num = mul_apple_graph.backward(dapple_price)
print(dapple,dapple_num,dorange,dorange_num,dtax)    # 입력값이 1변할때 출력값에 미치는 영향

"""그래디언트 디센던트  모멘텀 지역최저점"""

def celsius_to_fahrenheit(x):
    return x* 1.8 + 32

weight = np.random.uniform(0,5,1)     #0부터 5까지 전체 나오는 확률이 같다. 한개 만들겠다.
print(weight)
bias =0

# data_C = np.arange(0,100)
# data_F = celsius_to_fahrenheit(data_C)
# scaled_data = (data_C - data_C.min()/ (data_C.max()-data_C.min()))  #어차피 데이터 min 은 0이다.
# scaled_data_F = (data_F - data_F.min()/ (data_F.max()-data_F.min()))

"""min max scaling 민 맥스 스케일링   우리가 최대값 최소값을 모를때 이렇게 하면 된다."""

data_C = np.arange(0,100)
data_F = celsius_to_fahrenheit(data_C)
scaled_data_C = data_C / 100
scaled_data_F = data_F /100
print(scaled_data_C)
print(scaled_data_C.shape)
print(scaled_data_F)
print(scaled_data_F.shape)

a= (100)
print(type(a))
b= (100,)
print(type(b))
print(b)  #튜플 만들때 요소 하나짜리는 뒤에 , 하나 붙인다

weight_graph = mul_graph()
bias_graph = add_graph()

weighted_data_C = weight_graph.forward(scaled_data_C,weight)
predict_data =bias_graph.forward(weighted_data_C, bias)
print(predict_data)

dout= 1
dbias, dweighted_data= bias_graph.backward(dout)
print(dbias)
dscaled_data,dweight = weight_graph.backward(dweighted_data)
print(dweight)

mseGraph = mse_graph()
mse = mseGraph.forward(predict_data, scaled_data_F)
print(mse)

weight_mse_gradient, bias_mse_gradient = mseGraph.bakcward(scaled_data_C)
print(weight_mse_gradient)
print(bias_mse_gradient)

learning_rate = 0.01

learned_weight = weight - learning_rate * weight_mse_gradient *np.average(dweight)
learned_bias = bias - learning_rate * bias_mse_gradient *dbias
print(weight,learned_weight)
print(bias,learned_bias)

error_list = []
weight_list = []
bias_list = []     #매 폭마다 저장하고 싶다
for i in range(10000):
    #forward
    weighted_data_C = weight_graph.forward(weight,scaled_data_C)
    predict_data =bias_graph.forward(weighted_data_C,bias)
    #backward
    dout = 1
    dbias, dweighted_data= bias_graph.backward(dout)
    dweight,dscaled_data = weight_graph.backward(dweighted_data)
    #mse
    mse = mseGraph.forward(predict_data, scaled_data_F)
    error_list.append(mse)
    #mse gradient
    weight_mse_gradient, bias_mse_gradient = mseGraph.bakcward(scaled_data_C)
    #learning
    weight = weight - learning_rate * weight_mse_gradient *np.average(dweight)
    bias = bias - learning_rate * bias_mse_gradient *dbias
    weight_list.append(weight)
    bias_list.append(bias)
print(weight,bias)

plt.plot(error_list)

plt.plot(weight_list)

plt.plot(bias_list)
plt.show()

